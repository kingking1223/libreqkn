{"ast":null,"code":"\"use strict\";\n\n/**\n * Full blown HTML parsing based on htmlparser2.\n * Pulls in a heavy set of dependencies and thus WILL bloat your bundle size.\n * You have been warned.\n **/\nvar React = require('react');\nvar xtend = require('xtend');\nvar visit = require('unist-util-visit');\nvar HtmlToReact = require('html-to-react');\nvar symbols = require('../symbols');\nvar type = 'parsedHtml';\nvar selfClosingRe = /^<(area|base|br|col|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)\\s*\\/?>$/i;\nvar startTagRe = /^<([a-z]+)\\b/i;\nvar closingTagRe = /^<\\/([a-z]+)\\s*>$/;\nvar parser = new HtmlToReact.Parser();\nvar processNodeDefinitions = new HtmlToReact.ProcessNodeDefinitions(React);\nvar defaultConfig = {\n  isValidNode: function isValidNode(node) {\n    return node.type !== 'script';\n  },\n  processingInstructions: [{\n    shouldProcessNode: function shouldProcessNode() {\n      return true;\n    },\n    processNode: processNodeDefinitions.processDefaultNode\n  }]\n};\nfunction parseHtml(config, tree, props) {\n  var open;\n  var currentParent;\n  visit(tree, 'html', function (node, index, parent) {\n    if (!props.allowDangerousHtml && props.escapeHtml !== false) {\n      parent.children.splice(index, 1, {\n        type: 'text',\n        position: node.position,\n        value: node.value\n      });\n      return true;\n    }\n    if (props.skipHtml) {\n      parent.children.splice(index, 1);\n      return true;\n    }\n    if (currentParent !== parent) {\n      open = [];\n      currentParent = parent;\n    }\n    var selfClosing = getSelfClosingTagName(node);\n    if (selfClosing) {\n      parent.children.splice(index, 1, {\n        type: 'virtualHtml',\n        tag: selfClosing,\n        position: node.position\n      });\n      return true;\n    }\n    var current = parseNode(node, config);\n    if (!current || current.type === type) {\n      return true;\n    }\n    var matching = findAndPull(open, current.tag);\n    if (matching) {\n      parent.children.splice(index, 0, parsedHtml(current, matching, parent));\n    } else if (!current.opening) {\n      open.push(current);\n    }\n    return true;\n  }, true // Iterate in reverse\n  ); // Find any leftover HTML elements and blindly replace them with a parsed version\n\n  visit(tree, 'html', function (node, index, parent) {\n    var element = parser.parseWithInstructions(node.value, config.isValidNode, config.processingInstructions);\n    if (!element) {\n      parent.children.splice(index, 1);\n      return true;\n    }\n    parent.children.splice(index, 1, {\n      type: type,\n      element: element,\n      value: node.value,\n      position: node.position\n    });\n    return true;\n  });\n  return tree;\n}\nfunction findAndPull(open, matchingTag) {\n  var i = open.length;\n  while (i--) {\n    if (open[i].tag === matchingTag) {\n      return open.splice(i, 1)[0];\n    }\n  }\n  return false;\n}\nfunction parseNode(node, config) {\n  var match = node.value.trim().match(closingTagRe);\n  if (match) {\n    return {\n      tag: match[1],\n      opening: false,\n      node: node\n    };\n  }\n  var el = parser.parseWithInstructions(node.value, config.isValidNode, config.processingInstructions);\n  /* istanbul ignore if - seems to never happen. Hiding it because we plan on\n   * moving to rehype. */\n\n  if (!el) {\n    return false;\n  }\n  var isMultiple = React.Children.count(el) > 1;\n  var isSelfClosing = !isMultiple && selfClosingRe.test(\"<\".concat(el.type, \">\"));\n  if (isMultiple || isSelfClosing) {\n    return {\n      type: type,\n      position: node.position,\n      node: el\n    };\n  }\n  var startTagMatch = node.value.trim().match(startTagRe);\n  /* istanbul ignore next - seems itâ€™s always a start tag, hiding it because we\n   * plan on moving to rehype. */\n\n  var tag = startTagMatch ? startTagMatch[1] : el.type;\n  return {\n    tag: tag,\n    opening: true,\n    node: node,\n    element: el\n  };\n}\nfunction getSelfClosingTagName(node) {\n  var match = node.value.match(selfClosingRe);\n  return match ? match[1] : false;\n}\nfunction parsedHtml(fromNode, toNode, parent) {\n  var fromIndex = parent.children.indexOf(fromNode.node);\n  var toIndex = parent.children.indexOf(toNode.node);\n  var extracted = parent.children.splice(fromIndex, toIndex - fromIndex + 1);\n  var children = extracted.slice(1, -1);\n  return {\n    type: type,\n    children: children,\n    tag: fromNode.tag,\n    element: fromNode.element,\n    value: fromNode.node.value,\n    position: {\n      start: fromNode.node.position.start,\n      end: toNode.node.position.end,\n      indent: []\n    }\n  };\n}\nmodule.exports = function getHtmlParserPlugin(config, props) {\n  if (props && (typeof config.source !== 'undefined' || typeof config.children !== 'undefined')) {\n    throw new Error('react-markdown: `html-parser` must be called before use - see https://github.com/remarkjs/react-markdown#parsing-html');\n  }\n  var htmlConfig = xtend(defaultConfig, config || {});\n  var plugin = parseHtml.bind(null, htmlConfig);\n  plugin.identity = symbols.HtmlParser;\n  return plugin;\n};","map":{"version":3,"names":["React","require","xtend","visit","HtmlToReact","symbols","type","selfClosingRe","startTagRe","closingTagRe","parser","Parser","processNodeDefinitions","ProcessNodeDefinitions","defaultConfig","isValidNode","node","processingInstructions","shouldProcessNode","processNode","processDefaultNode","parseHtml","config","tree","props","open","currentParent","index","parent","allowDangerousHtml","escapeHtml","children","splice","position","value","skipHtml","selfClosing","getSelfClosingTagName","tag","current","parseNode","matching","findAndPull","parsedHtml","opening","push","element","parseWithInstructions","matchingTag","i","length","match","trim","el","isMultiple","Children","count","isSelfClosing","test","concat","startTagMatch","fromNode","toNode","fromIndex","indexOf","toIndex","extracted","slice","start","end","indent","module","exports","getHtmlParserPlugin","source","Error","htmlConfig","plugin","bind","identity","HtmlParser"],"sources":["/home/kingking/Documents/code/website/libreqkn/client/node_modules/react-markdown/lib/plugins/html-parser.js"],"sourcesContent":["\"use strict\";\n\n/**\n * Full blown HTML parsing based on htmlparser2.\n * Pulls in a heavy set of dependencies and thus WILL bloat your bundle size.\n * You have been warned.\n **/\nvar React = require('react');\n\nvar xtend = require('xtend');\n\nvar visit = require('unist-util-visit');\n\nvar HtmlToReact = require('html-to-react');\n\nvar symbols = require('../symbols');\n\nvar type = 'parsedHtml';\nvar selfClosingRe = /^<(area|base|br|col|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)\\s*\\/?>$/i;\nvar startTagRe = /^<([a-z]+)\\b/i;\nvar closingTagRe = /^<\\/([a-z]+)\\s*>$/;\nvar parser = new HtmlToReact.Parser();\nvar processNodeDefinitions = new HtmlToReact.ProcessNodeDefinitions(React);\nvar defaultConfig = {\n  isValidNode: function isValidNode(node) {\n    return node.type !== 'script';\n  },\n  processingInstructions: [{\n    shouldProcessNode: function shouldProcessNode() {\n      return true;\n    },\n    processNode: processNodeDefinitions.processDefaultNode\n  }]\n};\n\nfunction parseHtml(config, tree, props) {\n  var open;\n  var currentParent;\n  visit(tree, 'html', function (node, index, parent) {\n    if (!props.allowDangerousHtml && props.escapeHtml !== false) {\n      parent.children.splice(index, 1, {\n        type: 'text',\n        position: node.position,\n        value: node.value\n      });\n      return true;\n    }\n\n    if (props.skipHtml) {\n      parent.children.splice(index, 1);\n      return true;\n    }\n\n    if (currentParent !== parent) {\n      open = [];\n      currentParent = parent;\n    }\n\n    var selfClosing = getSelfClosingTagName(node);\n\n    if (selfClosing) {\n      parent.children.splice(index, 1, {\n        type: 'virtualHtml',\n        tag: selfClosing,\n        position: node.position\n      });\n      return true;\n    }\n\n    var current = parseNode(node, config);\n\n    if (!current || current.type === type) {\n      return true;\n    }\n\n    var matching = findAndPull(open, current.tag);\n\n    if (matching) {\n      parent.children.splice(index, 0, parsedHtml(current, matching, parent));\n    } else if (!current.opening) {\n      open.push(current);\n    }\n\n    return true;\n  }, true // Iterate in reverse\n  ); // Find any leftover HTML elements and blindly replace them with a parsed version\n\n  visit(tree, 'html', function (node, index, parent) {\n    var element = parser.parseWithInstructions(node.value, config.isValidNode, config.processingInstructions);\n\n    if (!element) {\n      parent.children.splice(index, 1);\n      return true;\n    }\n\n    parent.children.splice(index, 1, {\n      type: type,\n      element: element,\n      value: node.value,\n      position: node.position\n    });\n    return true;\n  });\n  return tree;\n}\n\nfunction findAndPull(open, matchingTag) {\n  var i = open.length;\n\n  while (i--) {\n    if (open[i].tag === matchingTag) {\n      return open.splice(i, 1)[0];\n    }\n  }\n\n  return false;\n}\n\nfunction parseNode(node, config) {\n  var match = node.value.trim().match(closingTagRe);\n\n  if (match) {\n    return {\n      tag: match[1],\n      opening: false,\n      node: node\n    };\n  }\n\n  var el = parser.parseWithInstructions(node.value, config.isValidNode, config.processingInstructions);\n  /* istanbul ignore if - seems to never happen. Hiding it because we plan on\n   * moving to rehype. */\n\n  if (!el) {\n    return false;\n  }\n\n  var isMultiple = React.Children.count(el) > 1;\n  var isSelfClosing = !isMultiple && selfClosingRe.test(\"<\".concat(el.type, \">\"));\n\n  if (isMultiple || isSelfClosing) {\n    return {\n      type: type,\n      position: node.position,\n      node: el\n    };\n  }\n\n  var startTagMatch = node.value.trim().match(startTagRe);\n  /* istanbul ignore next - seems itâ€™s always a start tag, hiding it because we\n   * plan on moving to rehype. */\n\n  var tag = startTagMatch ? startTagMatch[1] : el.type;\n  return {\n    tag: tag,\n    opening: true,\n    node: node,\n    element: el\n  };\n}\n\nfunction getSelfClosingTagName(node) {\n  var match = node.value.match(selfClosingRe);\n  return match ? match[1] : false;\n}\n\nfunction parsedHtml(fromNode, toNode, parent) {\n  var fromIndex = parent.children.indexOf(fromNode.node);\n  var toIndex = parent.children.indexOf(toNode.node);\n  var extracted = parent.children.splice(fromIndex, toIndex - fromIndex + 1);\n  var children = extracted.slice(1, -1);\n  return {\n    type: type,\n    children: children,\n    tag: fromNode.tag,\n    element: fromNode.element,\n    value: fromNode.node.value,\n    position: {\n      start: fromNode.node.position.start,\n      end: toNode.node.position.end,\n      indent: []\n    }\n  };\n}\n\nmodule.exports = function getHtmlParserPlugin(config, props) {\n  if (props && (typeof config.source !== 'undefined' || typeof config.children !== 'undefined')) {\n    throw new Error('react-markdown: `html-parser` must be called before use - see https://github.com/remarkjs/react-markdown#parsing-html');\n  }\n\n  var htmlConfig = xtend(defaultConfig, config || {});\n  var plugin = parseHtml.bind(null, htmlConfig);\n  plugin.identity = symbols.HtmlParser;\n  return plugin;\n};"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}